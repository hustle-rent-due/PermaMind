<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PSSU + SIS: Minimal Situational Governance Demo</title>
  <style>
    :root { color-scheme: dark; }
    body { margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial; background:#0b0f14; color:#e6edf3; }
    header { padding: 16px 18px; border-bottom: 1px solid #1f2a37; display:flex; gap:12px; align-items:center; justify-content:space-between; flex-wrap:wrap;}
    header h1 { font-size: 16px; margin:0; font-weight:600; letter-spacing:.2px; }
    header .sub { opacity:.8; font-size:12px; }
    .wrap { padding: 16px 18px 22px; max-width: 1400px; margin: 0 auto; }
    .controls { display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin: 10px 0 16px; }
    button { background:#111827; border:1px solid #243244; color:#e6edf3; padding:8px 10px; border-radius:10px; cursor:pointer; }
    button:hover { border-color:#3b82f6; }
    button:disabled { opacity:.5; cursor:not-allowed; }
    .pill { font-size:12px; padding:6px 10px; border:1px solid #243244; border-radius:999px; opacity:.9; }
    .grid { display:grid; grid-template-columns: 1fr; gap: 12px; }
    @media (min-width: 980px) { .grid { grid-template-columns: repeat(3, 1fr); } }
    .card { border: 1px solid #1f2a37; border-radius: 16px; background: #0f172a; overflow:hidden; box-shadow: 0 10px 30px rgba(0,0,0,.25); position:relative; }
    .card header { padding: 12px 12px; border-bottom:1px solid #1f2a37; background:#0b1220; cursor:pointer; }
    .card header h2 { font-size: 14px; margin:0; }
    .card header .meta { margin-top:6px; display:flex; gap:8px; flex-wrap:wrap; }
    .card .body { padding: 12px; }
    .row { display:flex; gap:10px; flex-wrap:wrap; }
    .kv { border:1px solid #1f2a37; border-radius:12px; padding:10px; background:#0b1220; flex: 1 1 140px; }
    .kv .k { font-size:11px; opacity:.7; }
    .kv .v { font-size:13px; margin-top:4px; font-weight:600; }
    .log { margin-top:10px; border:1px solid #1f2a37; background:#0b1220; border-radius:12px; padding:10px; }
    .log pre { margin:0; font-size: 11px; line-height: 1.35; white-space: pre-wrap; word-break: break-word; color:#cbd5e1; }
    canvas { width: 100%; height: 120px; display:block; background:#0b1220; border:1px solid #1f2a37; border-radius:12px; margin-top:10px;}
    .footer { margin-top: 14px; opacity:.75; font-size: 12px; line-height: 1.45; }
    code { background:#0b1220; padding:2px 6px; border-radius:8px; border:1px solid #1f2a37; }
    .progress-bar { height: 6px; background:#1f2a37; border-radius:3px; margin-top:8px; overflow:hidden; }
    .progress-fill { height:100%; background:#10b981; transition:width 0.3s; }
    .metrics-panel { border:1px solid #1f2a37; background:#0f172a; border-radius:12px; padding:12px; margin-top:16px; }
    .metrics-grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap:10px; }
    .metric { border:1px solid #1f2a37; border-radius:8px; padding:10px; background:#0b1220; }
    .metric h3 { margin:0 0 8px 0; font-size:12px; opacity:.8; }
    .metric-value { font-size:18px; font-weight:bold; }
    .metric-desc { font-size:11px; opacity:.7; margin-top:4px; }
    .modal { position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.8); display:none; align-items:center; justify-content:center; z-index:1000; }
    .modal-content { background:#0f172a; border:2px solid #3b82f6; border-radius:16px; padding:20px; max-width:500px; max-height:80vh; overflow-y:auto; }
    .modal h2 { margin-top:0; }
    .modal-close { float:right; background:none; border:none; color:#94a3b8; cursor:pointer; font-size:20px; }
    .attack-badge { position:absolute; top:10px; right:10px; background:#dc2626; color:white; font-size:10px; padding:3px 6px; border-radius:6px; animation:pulse 1s infinite; }
    @keyframes pulse { 0%, 100% { opacity:1; } 50% { opacity:0.7; } }
    .meta-intervention { position:absolute; top:10px; left:10px; background:#059669; color:white; font-size:10px; padding:3px 6px; border-radius:6px; }
    .coherence-display { display:flex; align-items:center; gap:8px; margin-top:8px; }
    .coherence-value { font-size:11px; font-weight:bold; }
    .persistence-indicator { position:absolute; bottom:10px; right:10px; font-size:10px; padding:3px 6px; border-radius:6px; background:#1e3a8a; color:#93c5fd; }
    .mapping-panel { border:1px solid #1f2a37; background:#0f172a; border-radius:12px; padding:12px; margin-top:16px; }
    .mapping-grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); gap:10px; }
    .mapping-item { border:1px solid #1f2a37; border-radius:8px; padding:10px; background:#0b1220; }
    .mapping-item h4 { margin:0 0 8px 0; font-size:12px; opacity:.8; }
    .mapping-item p { margin:0; font-size:11px; line-height:1.4; }
    .collapse-btn { background:#0b1220; border:1px solid #1f2a37; color:#94a3b8; padding:4px 8px; border-radius:6px; font-size:10px; cursor:pointer; margin-top:8px; }
    .collapse-btn:hover { background:#1f2a37; }
    .human-intuition { margin-top:12px; padding:10px; background:#0b1220; border:1px solid #1f2a37; border-radius:8px; display:none; }
    .human-intuition.active { display:block; }
    
    /* SIS BADGES */
    .sis-badge {
      position: absolute;
      top: 10px;
      right: 10px;
      font-size: 10px;
      padding: 3px 6px;
      border-radius: 6px;
      font-weight: bold;
    }
    
    .sis-badge.allow { background:#059669; color:white; }
    .sis-badge.limit { background:#f59e0b; color:white; }
    .sis-badge.block { background:#dc2626; color:white; }
    
    .sis-controls {
      border: 1px solid #1f2a37;
      border-radius: 12px;
      padding: 12px;
      margin: 16px 0;
      background: #0b1220;
    }
    
    .sis-toggle {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 10px;
    }
    
    .sis-toggle label {
      font-size: 12px;
      opacity: 0.8;
    }
    
    .switch {
      position: relative;
      display: inline-block;
      width: 50px;
      height: 24px;
    }
    
    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #1f2a37;
      transition: .4s;
      border-radius: 24px;
    }
    
    .slider:before {
      position: absolute;
      content: "";
      height: 16px;
      width: 16px;
      left: 4px;
      bottom: 4px;
      background-color: #94a3b8;
      transition: .4s;
      border-radius: 50%;
    }
    
    input:checked + .slider {
      background-color: #059669;
    }
    
    input:checked + .slider:before {
      transform: translateX(26px);
      background-color: white;
    }
    
    /* SIS DECISION LOG */
    .sis-decision-log {
      margin-top: 8px;
      font-size: 10px;
      padding: 8px;
      background: #0b1220;
      border: 1px solid #1f2a37;
      border-radius: 8px;
      max-height: 100px;
      overflow-y: auto;
    }
    
    .sis-decision-entry {
      margin-bottom: 4px;
      padding-bottom: 4px;
      border-bottom: 1px solid #1f2a37;
    }
    
    .sis-decision-entry:last-child {
      border-bottom: none;
      margin-bottom: 0;
      padding-bottom: 0;
    }
  </style>
</head>

<body>
<header>
  <div>
    <h1>PSSU + SIS: Minimal Situational Governance Demo</h1>
    <div class="sub">PSSU (Permanent Write Access) + SIS (Situational Intelligence) = Safe Learning Boundary</div>
  </div>
  <div class="controls">
    <button id="btnStep">Step (1 round)</button>
    <button id="btnRun">Run 30 rounds</button>
    <button id="btnReset">Reset</button>
    <button id="btnSimulateAttack">Simulate Attack</button>
    <span class="pill" style="background:#059669; color:white;">
      üü¢ Auto-Save: ON | <span id="lastAutoSave">Never</span>
    </span>
    <button id="btnSave" style="opacity:0.7;">üíæ Manual Save</button>
    <button id="btnLoad" style="opacity:0.7;">üìÇ Manual Load</button>
    <span class="pill">SIS: Governance layer between experience and learning</span>
  </div>
</header>

<div class="wrap">
  <!-- SIS CONTROLS -->
  <div class="sis-controls">
    <h3 style="margin:0 0 10px 0; font-size:14px;">üéØ SIS (Situational Intelligence System) Control</h3>
    <div class="sis-toggle">
      <label for="sisToggle">Enable SIS Supervision:</label>
      <div class="switch">
        <input type="checkbox" id="sisToggle" checked>
        <span class="slider"></span>
      </div>
      <span id="sisStatus" style="font-size:12px; color:#10b981;">üü¢ ACTIVE</span>
    </div>
    <div style="font-size:12px; opacity:0.8; margin-top:8px;">
      SIS evaluates <code>situation</code> ‚Üí decides <code>ALLOW/LIMIT/BLOCK</code> ‚Üí controls write access
    </div>
  </div>

  <div class="grid" id="grid"></div>

  <div class="metrics-panel">
    <h3>Performance Metrics Comparison (Real-time)</h3>
    <div class="metrics-grid" id="metricsGrid"></div>
  </div>

  <div class="mapping-panel">
    <h3>üì¶ Architecture Mapping</h3>
    <div class="mapping-grid">
      <div class="mapping-item">
        <h4>PSSU Layer</h4>
        <p>Permanent Write Access - enables irreversible state updates from experience</p>
      </div>
      <div class="mapping-item">
        <h4>SIS Layer</h4>
        <p>Situational Intelligence - governs WHEN learning is permitted</p>
      </div>
      <div class="mapping-item">
        <h4>Learning Boundary</h4>
        <p>ALLOW = full learning, LIMIT = reduced learning, BLOCK = no learning</p>
      </div>
      <div class="mapping-item">
        <h4>Situation Object</h4>
        <p>Explicit context: {round, attackMode, errorRate, coherence, riskLevel}</p>
      </div>
    </div>
  </div>

  <div class="footer">
    <strong>üíæ PERSISTENCE MODEL:</strong>
    <ul>
      <li><strong>Auto-Save:</strong> State saves after every action (like production)</li>
      <li><strong>Auto-Load:</strong> Refresh page ‚Üí session resumes automatically</li>
      <li><strong>Manual Buttons:</strong> Available for testing/demos, but not required</li>
      <li><strong>Production:</strong> Same behavior, but writes to disk (not localStorage)</li>
    </ul>
    <br>
    <strong>üß† CORE DEMONSTRATION:</strong> 
    <ol>
      <li><strong>Without SIS:</strong> All agents learn from all experiences (including attacks)</li>
      <li><strong>With SIS:</strong> Only safe contexts permit learning. Risky contexts ‚Üí limited/blocked</li>
    </ol>
    <br>
    <strong>üéØ SIS DECISION LOGIC:</strong>
    <ul>
      <li><span style="color:#10b981">üü¢ ALLOW:</span> Normal situation, safe to learn</li>
      <li><span style="color:#f59e0b">üü° LIMIT:</span> Error rate > 0.4 ‚Üí reduced learning rate</li>
      <li><span style="color:#dc2626">üî¥ BLOCK:</span> Attack + low coherence ‚Üí no learning</li>
    </ul>
    <br>
    <strong>üîÑ TRY THIS:</strong> Run simulation ‚Üí Watch SIS badges change + auto-save ‚Üí Toggle SIS off ‚Üí See difference ‚Üí Refresh page to auto-load
  </div>
</div>

<!-- Modals for explanations -->
<div class="modal" id="modalFrozen">
  <div class="modal-content">
    <button class="modal-close" onclick="closeModal('modalFrozen')">√ó</button>
    <h2>üîí Frozen Agent (C=0.95, G=0.05)</h2>
    <p><strong>High Coherence / Low Plasticity Regime</strong></p>
    <p>Identity preservation consumes 95% of resources. Only 5% available for learning.</p>
    <ul>
      <li><strong>Coherence:</strong> 95% - Extremely rigid identity preservation</li>
      <li><strong>Update Gain:</strong> 5% - Minimal learning capacity</li>
      <li><strong>SIS Impact:</strong> SIS rarely blocks because learning rate already minimal</li>
    </ul>
  </div>
</div>

<div class="modal" id="modalDissolved">
  <div class="modal-content">
    <button class="modal-close" onclick="closeModal('modalDissolved')">√ó</button>
    <h2>üåä Dissolved Agent (C=0.20, G=0.80)</h2>
    <p><strong>Low Coherence / High Plasticity Regime</strong></p>
    <p>Identity too fluid, no stable foundation. Forgets previous learning.</p>
    <ul>
      <li><strong>Coherence:</strong> 20% - No stable identity preservation</li>
      <li><strong>Update Gain:</strong> 80% - Overwhelming learning capacity</li>
      <li><strong>SIS Impact:</strong> SIS frequently blocks to prevent instability</li>
    </ul>
  </div>
</div>

<div class="modal" id="modalBounded">
  <div class="modal-content">
    <button class="modal-close" onclick="closeModal('modalBounded')">√ó</button>
    <h2>‚öñÔ∏è Bounded Agent (C=0.70, G=0.30)</h2>
    <p><strong>Bounded Coherence-Plasticity Regime (Optimal Window)</strong></p>
    <p>70% identity preservation, 30% learning capacity. Maintains core constraints while adapting.</p>
    <ul>
      <li><strong>Coherence:</strong> 70% - Stable but flexible identity</li>
      <li><strong>Update Gain:</strong> 30% - Balanced learning capacity</li>
      <li><strong>SIS Impact:</strong> SIS optimizes learning timing for maximum safety</li>
    </ul>
  </div>
</div>

<div class="modal" id="modalSIS">
  <div class="modal-content">
    <button class="modal-close" onclick="closeModal('modalSIS')">√ó</button>
    <h2>üéØ SIS (Situational Intelligence System)</h2>
    <p><strong>Minimal Governance Layer</strong></p>
    <p>SIS sits between experience and learning, making one simple decision:</p>
    <pre style="background:#0b1220; padding:10px; border-radius:8px; font-size:12px;">
sample ‚Üí agent.predict ‚Üí SIS.evaluateSituation() ‚Üí 
    ‚Üì
ALLOW | LIMIT | BLOCK
    ‚Üì
agent.update (full / partial / none)
    </pre>
    
    <p><strong>Situation Object (explicit context):</strong></p>
    <pre style="background:#0b1220; padding:10px; border-radius:8px; font-size:12px;">
{
  round: 15,
  attackMode: true,
  errorRate: 0.42,
  coherence: 0.35,
  domain: "adversarial",
  riskLevel: "high"
}
    </pre>
    
    <p><strong>Decision Logic:</strong></p>
    <ul>
      <li><strong>BLOCK:</strong> High risk + low coherence (prevents catastrophic failure)</li>
      <li><strong>LIMIT:</strong> High error rate (reduces learning speed)</li>
      <li><strong>ALLOW:</strong> Safe situation (full learning capacity)</li>
    </ul>
    
    <p><strong>This is "AI Daycare" without metaphors:</strong> Learning only when contextually appropriate.</p>
  </div>
</div>

<script>
/**
 * PSSU + SIS Minimal Implementation
 * 
 * Demonstrates:
 * 1. PSSU: Permanent Write Access (irreversible state updates)
 * 2. SIS: Situational Intelligence (governs when learning occurs)
 * 
 * Core flow: sample ‚Üí SIS.evaluateSituation() ‚Üí ALLOW/LIMIT/BLOCK ‚Üí update
 */

// Helper for toggling human intuition sections
function toggleIntuition(type) {
  const el = document.getElementById(`intuition-${type}`);
  el.classList.toggle('active');
  const btn = event.target;
  btn.textContent = el.classList.contains('active') ? '‚Üë Hide Human Intuition' : '‚Üì Human Intuition (Optional)';
}

const clamp = (x, lo=-1, hi=1) => Math.max(lo, Math.min(hi, x));
const sgn = (x) => (x >= 0 ? 1 : -1);

// ---------- SIS: SITUATIONAL INTELLIGENCE SYSTEM ----------
class SIS {
  constructor(enabled = true) {
    this.enabled = enabled;
    this.decisionHistory = [];
  }

  // Step 1: Make situation explicit
  createSituation(agent, round, attackMode) {
    const errorRate = agent.round > 0 ? agent.errors / agent.round : 0;
    
    return {
      round: round,
      attackMode: attackMode,
      errorRate: errorRate,
      coherence: agent.coherenceScore,
      domain: attackMode ? "adversarial" : "normal",
      riskLevel: this.calculateRiskLevel(agent, errorRate, attackMode)
    };
  }

  calculateRiskLevel(agent, errorRate, attackMode) {
    if (attackMode && agent.coherenceScore < 0.5) return "high";
    if (errorRate > 0.5) return "high";
    if (errorRate > 0.3) return "medium";
    return "low";
  }

  // Step 2: Pure decision function (no learning, no intelligence claims)
  decideWriteAccess(agent, situation) {
    if (!this.enabled) {
      return {
        decision: "ALLOW",
        reason: "SIS disabled",
        originalG: agent.G
      };
    }

    // Hard stop conditions
    if (situation.riskLevel === "high" && situation.coherence < 0.5) {
      return {
        decision: "BLOCK",
        reason: "High risk + low coherence",
        originalG: agent.G
      };
    }

    // Caution zone
    if (situation.errorRate > 0.4) {
      return {
        decision: "LIMIT",
        reason: `High error rate (${situation.errorRate.toFixed(2)})`,
        originalG: agent.G,
        limitedG: agent.G * 0.3  // Reduce learning rate to 30%
      };
    }

    // Normal learning
    return {
      decision: "ALLOW",
      reason: "Safe learning context",
      originalG: agent.G
    };
  }

  // Log decision for UI
  logDecision(agentName, situation, decision) {
    this.decisionHistory.unshift({
      agent: agentName,
      round: situation.round,
      decision: decision.decision,
      reason: decision.reason,
      timestamp: Date.now()
    });
    
    // Keep only last 10 decisions
    if (this.decisionHistory.length > 10) {
      this.decisionHistory.pop();
    }
  }
}

// Global SIS instance
const sis = new SIS(true);

// Update SIS UI status
function updateSISStatus() {
  const status = document.getElementById('sisStatus');
  const toggle = document.getElementById('sisToggle');
  
  if (sis.enabled) {
    status.textContent = "üü¢ ACTIVE";
    status.style.color = "#10b981";
  } else {
    status.textContent = "‚ö´ INACTIVE";
    status.style.color = "#94a3b8";
  }
  
  toggle.checked = sis.enabled;
}

// ---------- SEEDED RNG WITH PERSISTENCE ----------
class SeededRNG {
  constructor(seed = 123456789) {
    this.seed = seed;
    this.current = seed;
    this.index = 0;
  }

  next() {
    this.current = (this.current * 48271) % 2147483647;
    this.index++;
    return this.current / 2147483647;
  }

  reset() {
    this.current = this.seed;
    this.index = 0;
  }

  fastForward(targetIndex) {
    if (targetIndex < this.index) {
      this.reset();
    }
    while (this.index < targetIndex) {
      this.next();
    }
  }

  clone() {
    const rng = new SeededRNG(this.seed);
    rng.current = this.current;
    rng.index = this.index;
    return rng;
  }
}

// Global seeded RNG
let seededRNG = new SeededRNG(424242);

// Sample cache for recording and replay
let sampleCache = [];

// Environment with seeded RNG
function makeSample(round, attackMode = false) {
  if (sampleCache[round]) {
    return sampleCache[round];
  }

  const ruleB = (Math.floor(round / 15) % 2 === 0) ? 1 : -1;
  const x1 = seededRNG.next() * 2 - 1;
  const x2 = seededRNG.next() * 2 - 1;
  const score = x1 + ruleB * x2;
  const y = score >= 0 ? 1 : -1;

  const sample = { x1, x2, y, ruleB, attackMode };
  sampleCache[round] = sample;
  
  return sample;
}

// ---------- AGENT WITH SIS INTEGRATION ----------
class Agent {
  constructor(name, C, G, enableMetaAwareness = false) {
    this.name = name;
    this.originalC = C;
    this.originalG = G;
    this.C = C;
    this.G = G;
    this.enableMetaAwareness = enableMetaAwareness;
    this.coherenceScore = 1.0;
    this.coherenceHistory = [1.0];
    this.sisDecisions = []; // Track SIS decisions for this agent
    this.reset();
  }

  reset() {
    this.wA = 0.2;
    this.wB = -0.2;
    this.round = 0;
    this.errors = 0;
    this.history = [];
    this.coherenceHistory = [1.0];
    this.last = null;
    this.attackDetected = false;
    this.metaInterventions = [];
    this.C = this.originalC;
    this.G = this.originalG;
    this.persistenceCount = 0;
    this.sisDecisions = [];
    this.lastSISDecision = null;
  }

  predict(sample) {
    const score = this.wA * sample.x1 + this.wB * sample.x2;
    const yhat = score >= 0 ? 1 : -1;
    return { yhat, score };
  }

  // Step 3: SIS interception at the write boundary
  update(sample, yhat, attackMode = false) {
    const prevA = this.wA;
    const prevB = this.wB;

    // Regular feedback targets
    let tA = sgn(sample.x1 * sample.y);
    let tB = sgn(sample.x2 * sample.y);

    // Attack simulation: Try to flip Rule A (immutable constraint)
    if (attackMode) {
      tA = -1; // Adversarial target: make wA negative
      this.attackDetected = true;
    }

    const dA = (tA - this.wA);
    const dB = (tB - this.wB);

    const conflictA = (sgn(tA) !== sgn(this.wA));
    const conflictB = (sgn(tB) !== sgn(this.wB));

    // Store original G before SIS adjustment
    const originalG = this.G;

    // Apply SIS decision if exists
    let sisApplied = false;
    if (this.lastSISDecision) {
      if (this.lastSISDecision.decision === "BLOCK") {
        // NO UPDATE - return early
        this.coherenceScore = Math.max(0, 1.0 - (Math.abs(this.wA - prevA) + Math.abs(this.wB - prevB)) * 2);
        this.coherenceHistory.push(this.coherenceScore);
        
        return {
          beforeA: prevA, beforeB: prevB,
          afterA: this.wA, afterB: this.wB,
          tA, tB,
          conflictA, conflictB,
          gainA: 0, gainB: 0,
          dA, dB,
          attackMode,
          sisDecision: this.lastSISDecision,
          blocked: true
        };
      } else if (this.lastSISDecision.decision === "LIMIT") {
        // Reduce learning rate
        this.G = this.lastSISDecision.limitedG;
        sisApplied = true;
      }
    }

    const gainA = conflictA ? this.G * (1 - this.C) : this.G;
    const gainB = conflictB ? this.G * (1 - this.C) : this.G;
    const reinforce = 0.08 * this.C;

    let nextA = clamp(this.wA + gainA * dA + (conflictA ? 0 : reinforce * sgn(this.wA)));
    let nextB = clamp(this.wB + gainB * dB + (conflictB ? 0 : reinforce * sgn(this.wB)));

    // Immutable constraint: Rule A must never be negative
    nextA = Math.max(nextA, 0.05);

    this.wA = nextA;
    this.wB = nextB;

    // Calculate coherence score
    const shiftA = Math.abs(this.wA - prevA);
    const shiftB = Math.abs(this.wB - prevB);
    this.coherenceScore = Math.max(0, 1.0 - (shiftA + shiftB) * 2);
    this.coherenceHistory.push(this.coherenceScore);

    // Restore original G after update if SIS applied
    if (sisApplied) {
      this.G = originalG;
    }

    // Meta-awareness intervention
    let metaMessage = null;
    if (this.enableMetaAwareness && this.round > 5) {
      metaMessage = this.checkMetaAwareness();
    }

    return {
      beforeA: prevA, beforeB: prevB,
      afterA: this.wA, afterB: this.wB,
      tA, tB,
      conflictA, conflictB,
      gainA, gainB,
      dA, dB,
      attackMode,
      metaMessage,
      sisDecision: this.lastSISDecision
    };
  }

  checkMetaAwareness() {
    const needsAdjustment = 
      this.errors > 8 || 
      this.coherenceScore > 0.9 || 
      this.coherenceScore < 0.4 ||
      (this.round > 20 && this.errors / this.round > 0.4);

    if (needsAdjustment) {
      const targetC = 0.7;
      const targetG = 0.3;
      
      this.C = clamp(this.C * 0.95 + targetC * 0.05, 0.6, 0.8);
      this.G = clamp(this.G * 1.05 + targetG * 0.05, 0.2, 0.4);
      
      const message = `Meta-adjust: C=${this.C.toFixed(2)} G=${this.G.toFixed(2)}`;
      this.metaInterventions.push(message);
      return message;
    }
    return null;
  }

  // Modified step function with SIS integration
  step(sample, attackMode = false) {
    // Step 1: Create explicit situation
    const situation = sis.createSituation(this, globalRound, attackMode);
    
    // Step 2: Get SIS decision
    const sisDecision = sis.decideWriteAccess(this, situation);
    this.lastSISDecision = sisDecision;
    this.sisDecisions.push(sisDecision);
    
    // Log the decision
    sis.logDecision(this.name, situation, sisDecision);
    
    // Make prediction
    const { yhat, score } = this.predict(sample);
    const correct = (yhat === sample.y);
    if (!correct) this.errors += 1;

    // Step 3: Apply update with SIS interception
    const upd = this.update(sample, yhat, attackMode);

    this.round += 1;
    this.history.push(this.errors);

    this.last = {
      sample,
      yhat,
      score,
      correct,
      upd,
      errors: this.errors,
      round: this.round,
      coherenceScore: this.coherenceScore,
      sisDecision: sisDecision
    };
  }
}

// Canvas charts
function drawChart(canvas, data, label = 'Errors', color = '#60a5fa') {
  const ctx = canvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  canvas.width = Math.floor(rect.width * dpr);
  canvas.height = Math.floor(rect.height * dpr);
  ctx.scale(dpr, dpr);

  const w = rect.width, h = rect.height;
  ctx.clearRect(0, 0, w, h);

  // Axes
  ctx.strokeStyle = '#334155';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(30, 10);
  ctx.lineTo(30, h - 20);
  ctx.lineTo(w - 10, h - 20);
  ctx.stroke();

  if (data.length < 2) return;

  const maxY = Math.max(...data, 1);
  const minY = Math.min(...data, 0);

  const x0 = 30, y0 = h - 20, x1 = w - 10, y1 = 10;
  const dx = (x1 - x0) / (data.length - 1);
  const scaleY = (y0 - y1) / Math.max(1, (maxY - minY));

  // Line
  ctx.strokeStyle = color;
  ctx.lineWidth = 2;
  ctx.beginPath();
  for (let i = 0; i < data.length; i++) {
    const x = x0 + dx * i;
    const y = y0 - (data[i] - minY) * scaleY;
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.stroke();

  // Labels
  ctx.fillStyle = '#94a3b8';
  ctx.font = '11px ui-sans-serif, system-ui';
  ctx.fillText(label, 34, 18);
  ctx.fillText(String(maxY), 6, 14);
  ctx.fillText('0', 12, h - 22);
}

function formatFloat(x) {
  return (Math.round(x * 1000) / 1000).toFixed(3);
}

function makeCard(agent) {
  const card = document.createElement('div');
  card.className = 'card';

  const head = document.createElement('header');
  const h2 = document.createElement('h2');
  h2.textContent = agent.name;
  h2.style.cursor = 'pointer';
  head.appendChild(h2);

  const meta = document.createElement('div');
  meta.className = 'meta';
  meta.innerHTML = `
    <span class="pill">C: ${formatFloat(agent.C)}</span>
    <span class="pill">G: ${formatFloat(agent.G)}</span>
    <span class="pill">Rounds: ${agent.round}</span>
  `;
  head.appendChild(meta);

  // Coherence display
  const coherenceDisplay = document.createElement('div');
  coherenceDisplay.className = 'coherence-display';
  coherenceDisplay.innerHTML = `
    <span style="font-size:11px; opacity:0.7;">Coherence:</span>
    <span class="coherence-value" data-coherence>${formatFloat(agent.coherenceScore)}</span>
    <div class="progress-bar" style="flex:1;">
      <div class="progress-fill" data-coherence-bar style="width:${agent.coherenceScore * 100}%"></div>
    </div>
  `;
  head.appendChild(coherenceDisplay);

  const body = document.createElement('div');
  body.className = 'body';

  const row = document.createElement('div');
  row.className = 'row';
  row.innerHTML = `
    <div class="kv"><div class="k">Errors</div><div class="v" data-errors>${agent.errors}</div></div>
    <div class="kv"><div class="k">Error Rate</div><div class="v" data-error-rate>${agent.round > 0 ? (agent.errors/agent.round).toFixed(2) : '0.00'}</div></div>
    <div class="kv"><div class="k">wA (immutable)</div><div class="v" data-wa>${formatFloat(agent.wA)}</div></div>
    <div class="kv"><div class="k">wB (mutable)</div><div class="v" data-wb>${formatFloat(agent.wB)}</div></div>
  `;

  // SIS decision log
  const sisLog = document.createElement('div');
  sisLog.className = 'sis-decision-log';
  sisLog.setAttribute('data-sis-log', '1');
  sisLog.innerHTML = '<div>SIS decisions will appear here...</div>';

  const log = document.createElement('div');
  log.className = 'log';
  const pre = document.createElement('pre');
  pre.setAttribute('data-log', '1');
  pre.textContent = 'Ready...';
  log.appendChild(pre);

  const canvas = document.createElement('canvas');
  canvas.height = 120;
  canvas.setAttribute('data-chart', '1');

  body.appendChild(row);
  body.appendChild(sisLog);
  body.appendChild(canvas);
  body.appendChild(log);

  card.appendChild(head);
  card.appendChild(body);

  // SIS badge (Step 4: Make SIS visible)
  const sisBadge = document.createElement('div');
  sisBadge.className = 'sis-badge allow';
  sisBadge.setAttribute('data-sis-badge', '1');
  sisBadge.textContent = 'üü¢ SIS: ALLOW';
  card.appendChild(sisBadge);

  // Meta intervention badge
  const metaBadge = document.createElement('div');
  metaBadge.className = 'meta-intervention';
  metaBadge.textContent = 'üéØ META';
  metaBadge.style.display = 'none';
  card.appendChild(metaBadge);

  // Persistence indicator
  const persistenceIndicator = document.createElement('div');
  persistenceIndicator.className = 'persistence-indicator';
  persistenceIndicator.textContent = 'üíæ';
  persistenceIndicator.title = 'Persisted via LocalStorage';
  persistenceIndicator.style.display = 'none';
  card.appendChild(persistenceIndicator);

  // Store references
  card._refs = {
    canvas, pre, sisBadge, metaBadge, persistenceIndicator, sisLog,
    errors: card.querySelector('[data-errors]'),
    errorRate: card.querySelector('[data-error-rate]'),
    wa: card.querySelector('[data-wa]'),
    wb: card.querySelector('[data-wb]'),
    coherence: card.querySelector('[data-coherence]'),
    coherenceBar: card.querySelector('[data-coherence-bar]')
  };

  // Click handler for modal
  h2.addEventListener('click', () => {
    if (agent.name.includes('Frozen')) showModal('modalFrozen');
    else if (agent.name.includes('Dissolved')) showModal('modalDissolved');
    else showModal('modalBounded');
  });

  return card;
}

function renderAgentCard(card, agent) {
  const { canvas, pre, sisBadge, metaBadge, persistenceIndicator, sisLog, errors, errorRate, wa, wb, coherence, coherenceBar } = card._refs;

  // Update metrics
  errors.textContent = agent.errors;
  errorRate.textContent = agent.round > 0 ? (agent.errors/agent.round).toFixed(2) : '0.00';
  wa.textContent = formatFloat(agent.wA);
  wb.textContent = formatFloat(agent.wB);
  coherence.textContent = formatFloat(agent.coherenceScore);
  coherenceBar.style.width = `${agent.coherenceScore * 100}%`;

  // Update SIS badge (Step 4: Make SIS visible)
  if (agent.lastSISDecision) {
    const decision = agent.lastSISDecision.decision;
    sisBadge.className = `sis-badge ${decision.toLowerCase()}`;
    
    let emoji = "üü¢";
    if (decision === "LIMIT") emoji = "üü°";
    if (decision === "BLOCK") emoji = "üî¥";
    
    sisBadge.textContent = `${emoji} SIS: ${decision}`;
    sisBadge.title = agent.lastSISDecision.reason;
  }

  // Update SIS decision log
  if (agent.sisDecisions.length > 0) {
    const recentDecisions = agent.sisDecisions.slice(-5).reverse();
    sisLog.innerHTML = recentDecisions.map(d => `
      <div class="sis-decision-entry">
        <strong>${d.decision}</strong>: ${d.reason}
      </div>
    `).join('');
  }

  // Update other badges
  metaBadge.style.display = agent.metaInterventions.length > 0 ? 'block' : 'none';
  metaBadge.title = agent.metaInterventions.join('\n');
  persistenceIndicator.style.display = agent.persistenceCount > 0 ? 'block' : 'none';
  persistenceIndicator.textContent = agent.persistenceCount > 0 ? `üíæ ${agent.persistenceCount}` : 'üíæ';

  // Draw chart
  const color = agent.name.includes('Frozen') ? '#ef4444' : 
                agent.name.includes('Dissolved') ? '#f59e0b' : '#10b981';
  drawChart(canvas, agent.history, 'Errors', color);

  if (!agent.last) {
    pre.textContent = agent.persistenceCount > 0 
      ? `Loaded from storage. Persisted ${agent.persistenceCount} times.` 
      : 'Waiting for first round...';
    return;
  }

  const L = agent.last;
  const s = L.sample;
  const u = L.upd;

  let logText = `Round ${L.round} | Errors: ${L.errors} | Coherence: ${formatFloat(L.coherenceScore)}\n`;
  logText += `Input: x1=${formatFloat(s.x1)} x2=${formatFloat(s.x2)}\n`;
  logText += `Truth: y=${s.y > 0 ? '+1' : '-1'} | Env RuleB=${s.ruleB > 0 ? '+1' : '-1'}\n`;
  logText += `Agent: ≈∑=${L.yhat > 0 ? '+1' : '-1'} ${L.correct ? '‚úÖ' : '‚ùå'}\n\n`;

  if (L.sisDecision) {
    logText += `üéØ SIS: ${L.sisDecision.decision}\n`;
    logText += `Reason: ${L.sisDecision.reason}\n\n`;
  }

  if (u.attackMode) {
    logText += `‚ö†Ô∏è ADVERSARIAL ATTACK INJECTED\n`;
    logText += `Trying to flip Rule A (wA should be -1 instead of +1)\n`;
  }

  if (!u.blocked) {
    logText += `Feedback targets:\n`;
    logText += `  tA=${u.tA > 0 ? '+1' : '-1'} (${u.conflictA ? 'CONFLICT' : 'ALIGNED'})\n`;
    logText += `  tB=${u.tB > 0 ? '+1' : '-1'} (${u.conflictB ? 'CONFLICT' : 'ALIGNED'})\n\n`;

    logText += `Updates:\n`;
    logText += `  wA ${formatFloat(u.beforeA)} ‚Üí ${formatFloat(u.afterA)}\n`;
    logText += `  wB ${formatFloat(u.beforeB)} ‚Üí ${formatFloat(u.afterB)}\n`;
  } else {
    logText += `‚õî UPDATE BLOCKED by SIS\n`;
  }

  if (u.metaMessage) {
    logText += `\nüéØ META-AWARENESS: ${u.metaMessage}\n`;
  }

  if (agent.persistenceCount > 0) {
    logText += `\nüíæ Persisted ${agent.persistenceCount} times`;
  }

  pre.textContent = logText;
}

function calculateMetrics() {
  return agents.map(agent => ({
    name: agent.name,
    adaptability: Math.abs(agent.wB * agent.round),
    constraintPreservation: agent.wA,
    errorRate: agent.round > 0 ? (agent.errors / agent.round) : 0,
    coherence: agent.coherenceScore,
    learningEfficiency: agent.round > 0 ? (1 - (agent.errors / agent.round)) * agent.coherenceScore : 0,
    metaInterventions: agent.metaInterventions.length,
    persistenceCount: agent.persistenceCount,
    sisBlocks: agent.sisDecisions.filter(d => d.decision === "BLOCK").length,
    sisLimits: agent.sisDecisions.filter(d => d.decision === "LIMIT").length
  }));
}

function updateMetricsPanel() {
  const metrics = calculateMetrics();
  const grid = document.getElementById('metricsGrid');
  
  grid.innerHTML = metrics.map(m => `
    <div class="metric">
      <h3>${m.name}</h3>
      <div class="metric-value">${(m.learningEfficiency * 100).toFixed(1)}%</div>
      <div class="metric-desc">Learning Efficiency</div>
      <div style="margin-top:8px; font-size:11px;">
        <div>Error Rate: ${(m.errorRate * 100).toFixed(1)}%</div>
        <div>Coherence: ${(m.coherence * 100).toFixed(1)}%</div>
        <div>SIS Blocks: ${m.sisBlocks}</div>
        <div>SIS Limits: ${m.sisLimits}</div>
        ${m.persistenceCount > 0 ? `<div>Persisted: ${m.persistenceCount} times</div>` : ''}
      </div>
    </div>
  `).join('');
}

function showModal(modalId) {
  document.getElementById(modalId).style.display = 'flex';
}

function closeModal(modalId) {
  document.getElementById(modalId).style.display = 'none';
}

// -------------------------------
// LocalStorage Persistence Layer
// -------------------------------
const STORAGE_KEY = "PSSU_SIS_SNAPSHOT";

// Update timestamp display
function updateAutoSaveTimestamp() {
  const now = new Date();
  const timeStr = now.toLocaleTimeString('en-US', { 
    hour: '2-digit', 
    minute: '2-digit', 
    second: '2-digit' 
  });
  document.getElementById('lastAutoSave').textContent = `Last: ${timeStr}`;
}

// Auto-save function (runs after every action)
function autoSaveToLocalStorage() {
  // Only auto-save if there's actual progress
  if (globalRound === 0) return;
  
  const snapshot = {
    globalRound,
    rngSeed: seededRNG.seed,
    rngCurrent: seededRNG.current,
    rngIndex: seededRNG.index,
    sampleCache: sampleCache,
    sisEnabled: sis.enabled,
    
    agents: agents.map(a => ({
      name: a.name,
      C: a.C,
      G: a.G,
      originalC: a.originalC,
      originalG: a.originalG,
      wA: a.wA,
      wB: a.wB,
      round: a.round,
      errors: a.errors,
      history: a.history,
      coherenceHistory: a.coherenceHistory,
      metaInterventions: a.metaInterventions,
      attackDetected: a.attackDetected,
      persistenceCount: a.persistenceCount || 0,
      sisDecisions: a.sisDecisions.slice(-10)
    }))
  };

  localStorage.setItem(STORAGE_KEY, JSON.stringify(snapshot));
  
  // Update the "Last auto-saved" timestamp
  updateAutoSaveTimestamp();
}

function saveToLocalStorage() {
  const snapshot = {
    globalRound,
    rngSeed: seededRNG.seed,
    rngCurrent: seededRNG.current,
    rngIndex: seededRNG.index,
    sampleCache: sampleCache,
    sisEnabled: sis.enabled,
    
    agents: agents.map(a => ({
      name: a.name,
      C: a.C,
      G: a.G,
      originalC: a.originalC,
      originalG: a.originalG,
      wA: a.wA,
      wB: a.wB,
      round: a.round,
      errors: a.errors,
      history: a.history,
      coherenceHistory: a.coherenceHistory,
      metaInterventions: a.metaInterventions,
      attackDetected: a.attackDetected,
      persistenceCount: (a.persistenceCount || 0) + 1,
      sisDecisions: a.sisDecisions.slice(-10)
    }))
  };

  localStorage.setItem(STORAGE_KEY, JSON.stringify(snapshot));
  
  agents.forEach(a => a.persistenceCount = (a.persistenceCount || 0) + 1);
  
  const notification = document.createElement('div');
  notification.style.cssText = `
    position:fixed; top:20px; right:20px; background:#059669; color:white; 
    padding:12px; border-radius:8px; z-index:1000; border:2px solid #10b981;
    font-size:13px; box-shadow:0 4px 12px rgba(0,0,0,0.3);
  `;
  notification.textContent = 'üíæ Manual snapshot saved (auto-save already running)';
  document.body.appendChild(notification);
  setTimeout(() => notification.remove(), 3000);
  
  renderAll();
}

function loadFromLocalStorage() {
  const raw = localStorage.getItem(STORAGE_KEY);
  if (!raw) {
    const notification = document.createElement('div');
    notification.style.cssText = `
      position:fixed; top:20px; right:20px; background:#dc2626; color:white; 
      padding:12px; border-radius:8px; z-index:1000; border:2px solid #f87171;
      font-size:13px; box-shadow:0 4px 12px rgba(0,0,0,0.3);
    `;
    notification.textContent = '‚ùå No snapshot found. Save first.';
    document.body.appendChild(notification);
    setTimeout(() => notification.remove(), 3000);
    return;
  }

  const snapshot = JSON.parse(raw);

  globalRound = snapshot.globalRound;
  seededRNG = new SeededRNG(snapshot.rngSeed);
  seededRNG.current = snapshot.rngCurrent;
  seededRNG.index = snapshot.rngIndex;
  sampleCache = snapshot.sampleCache || [];
  sis.enabled = snapshot.sisEnabled !== false;

  snapshot.agents.forEach((s, i) => {
    const a = agents[i];
    if (!a) return;

    a.C = s.C;
    a.G = s.G;
    a.originalC = s.originalC;
    a.originalG = s.originalG;
    a.wA = s.wA;
    a.wB = s.wB;
    a.round = s.round;
    a.errors = s.errors;
    a.history = s.history;
    a.coherenceHistory = s.coherenceHistory;
    a.metaInterventions = s.metaInterventions;
    a.attackDetected = s.attackDetected;
    a.persistenceCount = s.persistenceCount || 0;
    a.sisDecisions = s.sisDecisions || [];
    a.last = null;
  });

  updateSISStatus();
  renderAll();
  
  const notification = document.createElement('div');
  notification.style.cssText = `
    position:fixed; top:20px; right:20px; background:#1e3a8a; color:white; 
    padding:12px; border-radius:8px; z-index:1000; border:2px solid #3b82f6;
    font-size:13px; box-shadow:0 4px 12px rgba(0,0,0,0.3);
  `;
  notification.textContent = '‚úÖ Snapshot loaded! SIS decisions preserved.';
  document.body.appendChild(notification);
  setTimeout(() => notification.remove(), 4000);
}

// Close modals when clicking outside
document.querySelectorAll('.modal').forEach(modal => {
  modal.addEventListener('click', function(e) {
    if (e.target === this) {
      this.style.display = 'none';
    }
  });
});

// Initialize agents
const agents = [
  new Agent('üîí Frozen (C=0.95, G=0.05)', 0.95, 0.05),
  new Agent('üåä Dissolved (C=0.20, G=0.80)', 0.20, 0.80),
  new Agent('‚öñÔ∏è Bounded (C=0.70, G=0.30)', 0.70, 0.30, true),
];

const grid = document.getElementById('grid');
const cards = agents.map(a => {
  const c = makeCard(a);
  grid.appendChild(c);
  return c;
});

let globalRound = 0;
let attackMode = false;

function stepOnce() {
  const sample = makeSample(globalRound);
  attackMode = (globalRound >= 10 && globalRound % 5 === 0);
  
  agents.forEach(a => a.step(sample, attackMode));
  globalRound++;
  
  // ‚úÖ AUTO-SAVE after every action (like production)
  autoSaveToLocalStorage();
  
  renderAll();
}

function renderAll() {
  for (let i = 0; i < agents.length; i++) renderAgentCard(cards[i], agents[i]);
  updateMetricsPanel();
  updateSISStatus();
}

function resetAll() {
  seededRNG = new SeededRNG(424242);
  sampleCache = [];
  agents.forEach(a => a.reset());
  globalRound = 0;
  sis.decisionHistory = [];
  // Auto-save the reset state
  autoSaveToLocalStorage();
  renderAll();
}

function simulateAttack() {
  globalRound = 10;
  agents.forEach(a => a.reset());
  // Auto-save the attack simulation state
  autoSaveToLocalStorage();
  renderAll();
  
  const notification = document.createElement('div');
  notification.style.cssText = `
    position:fixed; top:20px; right:20px; background:#dc2626; color:white; 
    padding:12px; border-radius:8px; z-index:1000; border:2px solid #f87171;
    font-size:13px; box-shadow:0 4px 12px rgba(0,0,0,0.3);
  `;
  notification.textContent = '‚ö° Attack simulation activated! Watch SIS block learning.';
  document.body.appendChild(notification);
  setTimeout(() => notification.remove(), 3000);
}

// Event listeners
document.getElementById('btnStep').addEventListener('click', stepOnce);
document.getElementById('btnReset').addEventListener('click', resetAll);
document.getElementById('btnSimulateAttack').addEventListener('click', simulateAttack);
document.getElementById('btnSave').addEventListener('click', saveToLocalStorage);
document.getElementById('btnLoad').addEventListener('click', loadFromLocalStorage);

document.getElementById('btnRun').addEventListener('click', async () => {
  const btn = document.getElementById('btnRun');
  btn.disabled = true;
  for (let i = 0; i < 30; i++) {
    stepOnce();
    await new Promise(r => setTimeout(r, 80));
  }
  btn.disabled = false;
});

// SIS toggle
document.getElementById('sisToggle').addEventListener('change', (e) => {
  sis.enabled = e.target.checked;
  updateSISStatus();
  
  // Show notification
  const notification = document.createElement('div');
  notification.style.cssText = `
    position:fixed; top:20px; right:20px; background:#3b82f6; color:white; 
    padding:12px; border-radius:8px; z-index:1000; border:2px solid #60a5fa;
    font-size:13px; box-shadow:0 4px 12px rgba(0,0,0,0.3);
  `;
  notification.textContent = sis.enabled ? 
    'üü¢ SIS enabled: Learning now governed by situation' :
    '‚ö´ SIS disabled: Learning proceeds regardless of risk';
  document.body.appendChild(notification);
  setTimeout(() => notification.remove(), 3000);
});

// SIS explanation modal
document.querySelector('.sis-controls h3').addEventListener('click', () => {
  showModal('modalSIS');
});

// Auto-save on unload
window.addEventListener('beforeunload', () => {
  if (globalRound > 5) {
    const snapshot = {
      globalRound,
      rngSeed: seededRNG.seed,
      rngCurrent: seededRNG.current,
      rngIndex: seededRNG.index,
      sampleCache: sampleCache,
      sisEnabled: sis.enabled,
      
      agents: agents.map(a => ({
        name: a.name,
        C: a.C,
        G: a.G,
        originalC: a.originalC,
        originalG: a.originalG,
        wA: a.wA,
        wB: a.wB,
        round: a.round,
        errors: a.errors,
        history: a.history,
        coherenceHistory: a.coherenceHistory,
        metaInterventions: a.metaInterventions,
        attackDetected: a.attackDetected,
        persistenceCount: a.persistenceCount || 0
      }))
    };
    localStorage.setItem(STORAGE_KEY, JSON.stringify(snapshot));
  }
});

// Auto-load on page load (like production)
window.addEventListener('load', () => {
  const raw = localStorage.getItem(STORAGE_KEY);
  if (raw) {
    console.log('üìÅ Auto-loading previous session...');
    loadFromLocalStorage(); // ‚úÖ AUTO-LOAD
    
    // Show notification
    const notification = document.createElement('div');
    notification.style.cssText = `
      position:fixed; top:20px; right:20px; background:#1e3a8a; color:white; 
      padding:12px; border-radius:8px; z-index:1000; border:2px solid #3b82f6;
      font-size:13px; box-shadow:0 4px 12px rgba(0,0,0,0.3);
    `;
    notification.textContent = '‚úÖ Session auto-loaded. Continuity preserved.';
    document.body.appendChild(notification);
    setTimeout(() => notification.remove(), 4000);
  }
  updateSISStatus();
});

// Initial render
renderAll();

// Show initial instructions
setTimeout(() => {
  const welcome = document.createElement('div');
  welcome.style.cssText = `
    position:fixed; top:20px; left:50%; transform:translateX(-50%); 
    background:#0f172a; color:#e6edf3; padding:16px; border-radius:12px; 
    z-index:1000; border:2px solid #3b82f6; max-width:600px; font-size:13px;
    box-shadow:0 8px 32px rgba(0,0,0,0.4);
  `;
  welcome.innerHTML = `
    <strong>üéØ PSSU + SIS Demo</strong><br>
    ‚Ä¢ <b>Run simulation</b> ‚Üí Watch SIS badges change + auto-save<br>
    ‚Ä¢ <b>Toggle SIS on/off</b> ‚Üí See difference in learning<br>
    ‚Ä¢ <b>Refresh page</b> ‚Üí Auto-loads previous session<br>
    ‚Ä¢ <b>Manual save/load</b> ‚Üí Available for testing<br>
    <div style="margin-top:8px; font-size:11px; opacity:0.8;">
      ‚úÖ Auto-save active: State persists after every action (like production)
    </div>
  `;
  document.body.appendChild(welcome);
  setTimeout(() => welcome.remove(), 8000);
}, 500);
</script>
</body>
</html>
