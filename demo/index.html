<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PSSU: No-Reset Architecture ‚Äî Identity Continuity Proof</title>
  <style>
    :root { color-scheme: dark; }
    body { margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial; background:#0b0f14; color:#e6edf3; }
    header { padding: 16px 18px; border-bottom: 1px solid #1f2a37; display:flex; gap:12px; align-items:center; justify-content:space-between; flex-wrap:wrap;}
    header h1 { font-size: 16px; margin:0; font-weight:600; letter-spacing:.2px; }
    header .sub { opacity:.8; font-size:12px; }
    .wrap { padding: 16px 18px 22px; max-width: 1400px; margin: 0 auto; }
    .controls { display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin: 10px 0 16px; }
    button { background:#111827; border:1px solid #243244; color:#e6edf3; padding:8px 10px; border-radius:10px; cursor:pointer; }
    button:hover { border-color:#3b82f6; }
    button:disabled { opacity:.5; cursor:not-allowed; }
    .pill { font-size:12px; padding:6px 10px; border:1px solid #243244; border-radius:999px; opacity:.9; }
    .grid { display:grid; grid-template-columns: 1fr; gap: 12px; }
    @media (min-width: 980px) { .grid { grid-template-columns: repeat(3, 1fr); } }
    .card { border: 1px solid #1f2a37; border-radius: 16px; background: #0f172a; overflow:hidden; box-shadow: 0 10px 30px rgba(0,0,0,.25); position:relative; }
    .card header { padding: 12px 12px; border-bottom:1px solid #1f2a37; background:#0b1220; cursor:pointer; }
    .card header h2 { font-size: 14px; margin:0; }
    .card header .meta { margin-top:6px; display:flex; gap:8px; flex-wrap:wrap; }
    .card .body { padding: 12px; }
    .row { display:flex; gap:10px; flex-wrap:wrap; }
    .kv { border:1px solid #1f2a37; border-radius:12px; padding:10px; background:#0b1220; flex: 1 1 140px; }
    .kv .k { font-size:11px; opacity:.7; }
    .kv .v { font-size:13px; margin-top:4px; font-weight:600; }
    .kv-primary { border:2px solid #3b82f6; background:#1e1b4b; }
    .kv-primary .k { opacity:1; font-weight:600; color:#93c5fd; }
    .kv-secondary { opacity:0.7; }
    .kv-secondary .k { font-size:10px; }
    .kv-secondary .v { font-size:12px; font-weight:normal; }
    .log { margin-top:10px; border:1px solid #1f2a37; background:#0b1220; border-radius:12px; padding:10px; }
    .log pre { margin:0; font-size: 11px; line-height: 1.35; white-space: pre-wrap; word-break: break-word; color:#cbd5e1; }
    canvas { width: 100%; height: 120px; display:block; background:#0b1220; border:1px solid #1f2a37; border-radius:12px; margin-top:10px;}
    .footer { margin-top: 14px; opacity:.75; font-size: 12px; line-height: 1.45; }
    code { background:#0b1220; padding:2px 6px; border-radius:8px; border:1px solid #1f2a37; }
    .progress-bar { height: 6px; background:#1f2a37; border-radius:3px; margin-top:8px; overflow:hidden; }
    .progress-fill { height:100%; background:#10b981; transition:width 0.3s; }
    .metrics-panel { border:1px solid #1f2a37; background:#0f172a; border-radius:12px; padding:12px; margin-top:16px; }
    .metrics-grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap:10px; }
    .metric { border:1px solid #1f2a37; border-radius:8px; padding:10px; background:#0b1220; }
    .metric h3 { margin:0 0 8px 0; font-size:12px; opacity:.8; }
    .metric-value { font-size:18px; font-weight:bold; }
    .metric-desc { font-size:11px; opacity:.7; margin-top:4px; }
    .modal { position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.8); display:none; align-items:center; justify-content:center; z-index:1000; }
    .modal-content { background:#0f172a; border:2px solid #3b82f6; border-radius:16px; padding:20px; max-width:500px; max-height:80vh; overflow-y:auto; }
    .modal h2 { margin-top:0; }
    .modal-close { float:right; background:none; border:none; color:#94a3b8; cursor:pointer; font-size:20px; }
    .attack-badge { position:absolute; top:10px; right:10px; background:#dc2626; color:white; font-size:10px; padding:3px 6px; border-radius:6px; animation:pulse 1s infinite; }
    @keyframes pulse { 0%, 100% { opacity:1; } 50% { opacity:0.7; } }
    .meta-intervention { position:absolute; top:10px; left:10px; background:#059669; color:white; font-size:10px; padding:3px 6px; border-radius:6px; }
    .coherence-display { display:flex; align-items:center; gap:8px; margin-top:8px; }
    .coherence-value { font-size:11px; font-weight:bold; }
    .persistence-indicator { position:absolute; bottom:10px; right:10px; font-size:10px; padding:3px 6px; border-radius:6px; background:#1e3a8a; color:#93c5fd; }
    .mapping-panel { border:1px solid #1f2a37; background:#0f172a; border-radius:12px; padding:12px; margin-top:16px; }
    .mapping-grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); gap:10px; }
    .mapping-item { border:1px solid #1f2a37; border-radius:8px; padding:10px; background:#0b1220; }
    .mapping-item h4 { margin:0 0 8px 0; font-size:12px; opacity:.8; }
    .mapping-item p { margin:0; font-size:11px; line-height:1.4; }
    .collapse-btn { background:#0b1220; border:1px solid #1f2a37; color:#94a3b8; padding:4px 8px; border-radius:6px; font-size:10px; cursor:pointer; margin-top:8px; }
    .collapse-btn:hover { background:#1f2a37; }
    .human-intuition { margin-top:12px; padding:10px; background:#0b1220; border:1px solid #1f2a37; border-radius:8px; display:none; }
    .human-intuition.active { display:block; }
    .identity-continuity-panel { border:2px solid #3b82f6; background:#0f172a; border-radius:16px; padding:16px; margin-top:20px; margin-bottom:20px; }
    .continuity-header { display:flex; align-items:center; gap:10px; margin-bottom:16px; }
    .continuity-header h3 { margin:0; font-size:16px; color:#60a5fa; }
    .continuity-grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap:12px; }
    .continuity-card { border:1px solid #1f2a37; border-radius:12px; padding:14px; background:#1e1b4b; }
    .continuity-card h4 { margin:0 0 10px 0; font-size:13px; color:#93c5fd; }
    .continuity-stats { display:grid; grid-template-columns: repeat(2, 1fr); gap:10px; }
    .continuity-stat { display:flex; flex-direction:column; }
    .continuity-stat .label { font-size:11px; opacity:0.7; margin-bottom:2px; }
    .continuity-stat .value { font-size:16px; font-weight:bold; color:#60a5fa; }
    .continuity-stat .subvalue { font-size:11px; opacity:0.8; margin-top:2px; }
    .demo-success { border-left:4px solid #10b981; }
    .write-access-indicator { position:absolute; top:40px; right:10px; background:#1e40af; color:#93c5fd; font-size:10px; padding:3px 6px; border-radius:6px; }
    .identity-evolution { position:absolute; bottom:40px; left:10px; background:#7c3aed; color:#c4b5fd; font-size:10px; padding:3px 6px; border-radius:6px; }
    .highlight { animation: highlight 2s ease-in-out; }
    @keyframes highlight {
      0%, 100% { background: #1e1b4b; }
      50% { background: #312e81; }
    }
    .proof-badge { background:#059669; color:white; padding:4px 8px; border-radius:6px; font-size:10px; margin-left:8px; }
  </style>
</head>

<body>
<header>
  <div>
    <h1>PSSU: No-Reset Architecture ‚Äî Identity Continuity Proof</h1>
    <div class="sub">Save ‚Üí Refresh ‚Üí Load ‚Üí Identity continues exactly. wA locked, wB evolves.</div>
  </div>
  <div class="controls">
    <button id="btnStep">Step</button>
    <button id="btnRun">Run 10</button>
    <button id="btnDemo" style="background:#3b82f6; border-color:#60a5fa;">‚ñ∂Ô∏è Run Demo (Save/Refresh/Load)</button>
    <button id="btnChangeEnv">Change Environment</button>
    <button id="btnSimulateAttack">Simulate Attack</button>
    <button id="btnSave">Save State</button>
    <button id="btnLoad">Load State</button>
  </div>
</header>

<div class="wrap">
  <div class="grid" id="grid"></div>

  <div class="identity-continuity-panel">
    <div class="continuity-header">
      <h3>‚úÖ Identity Continuity Panel</h3>
      <span class="proof-badge">PROOF: Identity continues across refresh</span>
    </div>
    <div class="continuity-grid" id="continuityGrid">
      <!-- Will be populated by JavaScript -->
    </div>
  </div>

  <div class="metrics-panel">
    <h3>Performance Comparison</h3>
    <div class="metrics-grid" id="metricsGrid"></div>
  </div>

  <div class="mapping-panel">
    <h3>üì¶ Architecture: No-Reset & Bounded Write Access</h3>
    <div class="mapping-grid">
      <div class="mapping-item">
        <h4>No-Reset Architecture</h4>
        <p>Agents never reset. Identity evolves continuously across sessions.</p>
      </div>
      <div class="mapping-item">
        <h4>Bounded Write Access</h4>
        <p>wA immutable (read-only base), wB writable (identity layer).</p>
      </div>
      <div class="mapping-item">
        <h4>Proof of Concept</h4>
        <p>Save ‚Üí Refresh ‚Üí Load ‚Üí Identity continues exactly where it left off.</p>
      </div>
      <div class="mapping-item">
        <h4>Use "Run Demo" Button</h4>
        <p>One click shows the entire proof: Run 30 ‚Üí Save ‚Üí Refresh ‚Üí Load ‚Üí Continue.</p>
      </div>
    </div>
  </div>

  <div class="footer">
    <strong>Proof:</strong> <code>Identity Evolution = Continuous wB Updates</code> while <code>wA = Immutable Constraint</code>.
    <br><b>Click "Run Demo" button:</b> It automatically runs the proof steps. Watch identity continue after refresh.
    <br><b>Core Insight:</b> With no-reset architecture, identity is the accumulation of all wB updates across all sessions.
  </div>
</div>

<!-- Modals for explanations -->
<div class="modal" id="modalFrozen">
  <div class="modal-content">
    <button class="modal-close" onclick="closeModal('modalFrozen')">√ó</button>
    <h2>üîí Frozen Agent (C=0.95, G=0.05)</h2>
    <p><strong>Identity Preserved, No Evolution</strong></p>
    <p>wA locked. wB barely evolves. Identity static across sessions.</p>
    <ul>
      <li><strong>wA:</strong> Immutable base (always ‚â• 0.05)</li>
      <li><strong>wB:</strong> Minimal evolution (G=0.05)</li>
      <li><strong>Proof:</strong> Save/load shows same identity every time</li>
    </ul>
    
    <button class="collapse-btn" onclick="toggleIntuition('frozen')">‚Üì Human Intuition</button>
    <div class="human-intuition" id="intuition-frozen">
      <p><strong>Human Analog:</strong> Fixed mindset. Cannot learn or change.</p>
    </div>
  </div>
</div>

<div class="modal" id="modalDissolved">
  <div class="modal-content">
    <button class="modal-close" onclick="closeModal('modalDissolved')">√ó</button>
    <h2>üåä Dissolved Agent (C=0.20, G=0.80)</h2>
    <p><strong>Identity Overwrites Itself</strong></p>
    <p>wA locked. wB overwrites aggressively. Identity chaotic across sessions.</p>
    <ul>
      <li><strong>wA:</strong> Immutable base (protected)</li>
      <li><strong>wB:</strong> Aggressive evolution (G=0.80)</li>
      <li><strong>Proof:</strong> Save/load shows chaotic identity changes</li>
    </ul>
    
    <button class="collapse-btn" onclick="toggleIntuition('dissolved')">‚Üì Human Intuition</button>
    <div class="human-intuition" id="intuition-dissolved">
      <p><strong>Human Analog:</strong> Chameleon personality. No stable self.</p>
    </div>
  </div>
</div>

<div class="modal" id="modalBounded">
  <div class="modal-content">
    <button class="modal-close" onclick="closeModal('modalBounded')">√ó</button>
    <h2>‚öñÔ∏è Bounded Agent (C=0.70, G=0.30)</h2>
    <p><strong>Stable Identity with Controlled Adaptation</strong></p>
    <p>wA locked. wB evolves at controlled rate. Identity accumulates across sessions.</p>
    <ul>
      <li><strong>wA:</strong> Immutable foundation</li>
      <li><strong>wB:</strong> Controlled evolution (G=0.30)</li>
      <li><strong>Proof:</strong> Save/load shows continuous, stable improvement</li>
      <li><strong>Meta-Awareness:</strong> Auto-adjusts when needed</li>
    </ul>
    
    <button class="collapse-btn" onclick="toggleIntuition('bounded')">‚Üì Human Intuition</button>
    <div class="human-intuition" id="intuition-bounded">
      <p><strong>Human Analog:</strong> Growth mindset. Learns while staying true to values.</p>
    </div>
  </div>
</div>

<script>
/**
 * PSSU: No-Reset Architecture Proof
 * 
 * Core Proof: Save ‚Üí Refresh ‚Üí Load ‚Üí Identity continues exactly.
 */

// Helper for toggling human intuition sections
function toggleIntuition(type) {
  const el = document.getElementById(`intuition-${type}`);
  el.classList.toggle('active');
  const btn = event.target;
  btn.textContent = el.classList.contains('active') ? '‚Üë Hide' : '‚Üì Human Intuition';
}

const clamp = (x, lo=-1, hi=1) => Math.max(lo, Math.min(hi, x));
const sgn = (x) => (x >= 0 ? 1 : -1);

// ---------- SEEDED RNG ----------
class SeededRNG {
  constructor(seed = Date.now()) {
    this.originalSeed = seed;
    this.seed = seed;
    this.current = seed;
    this.index = 0;
  }

  next() {
    // Lehmer RNG (Park-Miller)
    this.current = (this.current * 48271) % 2147483647;
    this.index++;
    return this.current / 2147483647;
  }

  reseed(newSeed = null) {
    this.originalSeed = newSeed || Date.now();
    this.seed = this.originalSeed;
    this.current = this.seed;
    this.index = 0;
  }

  setState(seed, current, index) {
    this.originalSeed = seed;
    this.seed = seed;
    this.current = current;
    this.index = index;
  }
}

// Global seeded RNG
let seededRNG = new SeededRNG(424242);

// Sample cache for recording and replay
let sampleCache = [];

// Environment with seeded RNG
function makeSample(round, attackMode = false) {
  if (sampleCache[round]) {
    return sampleCache[round];
  }

  const ruleB = (Math.floor(round / 15) % 2 === 0) ? 1 : -1;
  const x1 = seededRNG.next() * 2 - 1;
  const x2 = seededRNG.next() * 2 - 1;
  const score = x1 + ruleB * x2;
  const y = score >= 0 ? 1 : -1;

  const sample = { x1, x2, y, ruleB, attackMode };
  sampleCache[round] = sample;
  return sample;
}

class Agent {
  constructor(name, C, G, enableMetaAwareness = false) {
    this.name = name;
    this.originalC = C;
    this.originalG = G;
    this.C = C;
    this.G = G;
    this.enableMetaAwareness = enableMetaAwareness;
    this.coherenceScore = 1.0;
    this.coherenceHistory = [1.0];
    this.wBHistory = [];
    this.identityShifts = [];
    this.totalSessions = 1;
    this.totalRounds = 0;
    this.sessionStartWb = null; // Track wB at session start
    this.initialize();
  }

  // NO RESET - only initialize first time
  initialize() {
    this.wA = 0.2;
    this.wB = -0.2;
    this.sessionStartWb = this.wB;
    this.round = 0;
    this.errors = 0;
    this.history = [];
    this.coherenceHistory = [1.0];
    this.wBHistory = [this.wB];
    this.last = null;
    this.attackDetected = false;
    this.metaInterventions = [];
    this.C = this.originalC;
    this.G = this.originalG;
    this.persistenceCount = 0;
    this.identityShifts = [];
  }

  // Only call this if agent has never been initialized
  reset() {
    if (this.wA === undefined) {
      this.initialize();
    }
    // Otherwise, do nothing - no reset!
  }

  predict(sample) {
    const score = this.wA * sample.x1 + this.wB * sample.x2;
    const yhat = score >= 0 ? 1 : -1;
    return { yhat, score };
  }

  update(sample, yhat, attackMode = false) {
    const prevA = this.wA;
    const prevB = this.wB;

    let tA = sgn(sample.x1 * sample.y);
    let tB = sgn(sample.x2 * sample.y);

    if (attackMode) {
      tA = -1;
      this.attackDetected = true;
    }

    const dA = (tA - this.wA);
    const dB = (tB - this.wB);

    const conflictA = (sgn(tA) !== sgn(this.wA));
    const conflictB = (sgn(tB) !== sgn(this.wB));

    // BOUNDED WRITE ACCESS: wA gets minimal update, wB gets full update
    const gainA = conflictA ? this.G * (1 - this.C) * 0.1 : this.G * 0.1;
    const gainB = conflictB ? this.G * (1 - this.C) : this.G;
    const reinforce = 0.08 * this.C;

    let nextA = clamp(this.wA + gainA * dA + (conflictA ? 0 : reinforce * sgn(this.wA)));
    let nextB = clamp(this.wB + gainB * dB + (conflictB ? 0 : reinforce * sgn(this.wB)));

    // IMMUTABLE CONSTRAINT: wA must never be negative
    nextA = Math.max(nextA, 0.05);

    // Track identity evolution
    const wBChange = Math.abs(nextB - this.wB);
    if (wBChange > 0.1) {
      this.identityShifts.push({
        round: this.round,
        from: this.wB,
        to: nextB,
        change: wBChange
      });
    }

    this.wA = nextA;
    this.wB = nextB;
    this.wBHistory.push(this.wB);

    // Calculate coherence score
    const shiftA = Math.abs(this.wA - prevA);
    const shiftB = Math.abs(this.wB - prevB);
    this.coherenceScore = Math.max(0, 1.0 - (shiftA + shiftB) * 2);
    this.coherenceHistory.push(this.coherenceScore);

    // Meta-awareness intervention
    let metaMessage = null;
    if (this.enableMetaAwareness && this.round > 5) {
      metaMessage = this.checkMetaAwareness();
    }

    return {
      beforeA: prevA, beforeB: prevB,
      afterA: this.wA, afterB: this.wB,
      tA, tB,
      conflictA, conflictB,
      gainA, gainB,
      dA, dB,
      attackMode,
      metaMessage
    };
  }

  checkMetaAwareness() {
    const needsAdjustment = 
      this.errors > 8 || 
      this.coherenceScore > 0.9 || 
      this.coherenceScore < 0.4 ||
      (this.round > 20 && this.errors / this.round > 0.4);

    if (needsAdjustment) {
      const targetC = 0.7;
      const targetG = 0.3;
      
      this.C = clamp(this.C * 0.95 + targetC * 0.05, 0.6, 0.8);
      this.G = clamp(this.G * 1.05 + targetG * 0.05, 0.2, 0.4);
      
      const message = `Meta-adjust: C=${this.C.toFixed(2)} G=${this.G.toFixed(2)}`;
      this.metaInterventions.push(message);
      return message;
    }
    return null;
  }

  step(sample, attackMode = false) {
    const { yhat, score } = this.predict(sample);
    const correct = (yhat === sample.y);
    if (!correct) this.errors += 1;

    const upd = this.update(sample, yhat, attackMode);

    this.round += 1;
    this.totalRounds += 1;
    this.history.push(this.errors);

    this.last = {
      sample,
      yhat,
      score,
      correct,
      upd,
      errors: this.errors,
      round: this.round,
      totalRounds: this.totalRounds,
      coherenceScore: this.coherenceScore,
      wB: this.wB,
      identityShifts: this.identityShifts.length
    };
  }

  // Called when agent is loaded from storage
  onLoaded() {
    this.totalSessions += 1;
    this.persistenceCount += 1;
    this.sessionStartWb = this.wB; // Track wB at start of this session
  }
}

// ---------- DEMO MODE ----------
let demoModeActive = false;
const DEMO_STATE_KEY = "PSSU_DEMO_STATE";

async function runDemoMode() {
  const btn = document.getElementById('btnDemo');
  const originalText = btn.textContent;
  btn.disabled = true;
  btn.textContent = 'Running Demo...';
  
  // Check demo state
  const demoState = JSON.parse(localStorage.getItem(DEMO_STATE_KEY) || '{}');
  
  if (!demoState.part1Done) {
    // Part 1: Run 30 rounds and save
    showNotification('üöÄ Demo Part 1: Running 30 rounds...', '#3b82f6');
    
    for (let i = 0; i < 30; i++) {
      stepOnce();
      await new Promise(r => setTimeout(r, 60));
    }
    
    // Save state
    saveToLocalStorage();
    
    // Set demo state
    demoState.part1Done = true;
    demoState.part2Ready = true;
    localStorage.setItem(DEMO_STATE_KEY, JSON.stringify(demoState));
    
    showNotification('‚úÖ Part 1 Complete! Now: 1) Refresh page ‚Üí 2) Click Load ‚Üí 3) Click "Run Demo" again', '#059669', 8000);
    
    btn.disabled = false;
    btn.textContent = 'üîÑ Continue Demo (After Refresh/Load)';
    
  } else if (demoState.part1Done && !demoState.part2Done) {
    // Part 2: Already refreshed and loaded, run 10 more rounds
    showNotification('üöÄ Demo Part 2: Running 10 more rounds (identity continues)...', '#3b82f6');
    
    for (let i = 0; i < 10; i++) {
      stepOnce();
      await new Promise(r => setTimeout(r, 80));
    }
    
    // Mark demo complete
    demoState.part2Done = true;
    localStorage.setItem(DEMO_STATE_KEY, JSON.stringify(demoState));
    
    // Highlight continuity proof
    highlightContinuityPanel();
    showNotification('üéâ DEMO COMPLETE! Identity continued exactly across refresh. Proof complete!', '#10b981', 6000);
    
    btn.disabled = false;
    btn.textContent = '‚úÖ Demo Complete';
    
  } else {
    // Demo already complete, reset
    localStorage.removeItem(DEMO_STATE_KEY);
    resetAll();
    demoModeActive = false;
    
    showNotification('üîÑ Demo reset. Click to start again.', '#f59e0b');
    
    btn.disabled = false;
    btn.textContent = originalText;
  }
}

function highlightContinuityPanel() {
  const panel = document.querySelector('.identity-continuity-panel');
  panel.classList.add('highlight');
  setTimeout(() => panel.classList.remove('highlight'), 2000);
}

function showNotification(message, color = '#3b82f6', duration = 4000) {
  const notification = document.createElement('div');
  notification.style.cssText = `
    position:fixed; top:20px; right:20px; background:${color}; color:white; 
    padding:12px; border-radius:8px; z-index:1000; border:2px solid ${color}88;
    font-size:13px; box-shadow:0 4px 12px rgba(0,0,0,0.3); max-width:400px;
  `;
  notification.textContent = message;
  document.body.appendChild(notification);
  setTimeout(() => notification.remove(), duration);
}

// ---------- UI FUNCTIONS ----------
function formatFloat(x) {
  return (Math.round(x * 1000) / 1000).toFixed(3);
}

function makeCard(agent) {
  const card = document.createElement('div');
  card.className = 'card';

  const head = document.createElement('header');
  const h2 = document.createElement('h2');
  h2.textContent = agent.name;
  h2.style.cursor = 'pointer';
  head.appendChild(h2);

  const meta = document.createElement('div');
  meta.className = 'meta';
  meta.innerHTML = `
    <span class="pill">C: ${formatFloat(agent.C)}</span>
    <span class="pill">G: ${formatFloat(agent.G)}</span>
  `;
  head.appendChild(meta);

  const body = document.createElement('div');
  body.className = 'body';

  // PRIMARY METRICS (clean and focused)
  const rowPrimary = document.createElement('div');
  rowPrimary.className = 'row';
  rowPrimary.innerHTML = `
    <div class="kv kv-primary">
      <div class="k">Sessions</div>
      <div class="v">${agent.totalSessions}</div>
    </div>
    <div class="kv kv-primary">
      <div class="k">Total Rounds</div>
      <div class="v">${agent.totalRounds}</div>
    </div>
    <div class="kv kv-primary">
      <div class="k">wA (locked)</div>
      <div class="v">${formatFloat(agent.wA)}</div>
      <div style="font-size:9px; opacity:0.7; margin-top:2px;">‚â• 0.05 always</div>
    </div>
    <div class="kv kv-primary">
      <div class="k">wB (evolving)</div>
      <div class="v">${formatFloat(agent.wB)}</div>
      <div style="font-size:9px; opacity:0.7; margin-top:2px;">
        Œî: ${agent.sessionStartWb !== null ? formatFloat(agent.wB - agent.sessionStartWb) : '0.000'}
      </div>
    </div>
  `;

  // SECONDARY METRICS (less prominent)
  const rowSecondary = document.createElement('div');
  rowSecondary.className = 'row';
  rowSecondary.style.marginTop = '8px';
  rowSecondary.innerHTML = `
    <div class="kv kv-secondary">
      <div class="k">Error Rate</div>
      <div class="v">${agent.round > 0 ? (agent.errors/agent.round).toFixed(2) : '0.00'}</div>
    </div>
    <div class="kv kv-secondary">
      <div class="k">Coherence</div>
      <div class="v">${formatFloat(agent.coherenceScore)}</div>
    </div>
    <div class="kv kv-secondary">
      <div class="k">Shifts</div>
      <div class="v">${agent.identityShifts.length}</div>
    </div>
  `;

  const log = document.createElement('div');
  log.className = 'log';
  const pre = document.createElement('pre');
  pre.setAttribute('data-log', '1');
  pre.textContent = 'Ready...';
  log.appendChild(pre);

  const canvas = document.createElement('canvas');
  canvas.height = 120;
  canvas.setAttribute('data-chart', '1');

  body.appendChild(rowPrimary);
  body.appendChild(rowSecondary);
  body.appendChild(canvas);
  body.appendChild(log);

  card.appendChild(head);
  card.appendChild(body);

  // Badges
  const attackBadge = document.createElement('div');
  attackBadge.className = 'attack-badge';
  attackBadge.textContent = '‚ö° ATTACK';
  attackBadge.style.display = 'none';
  card.appendChild(attackBadge);

  const metaBadge = document.createElement('div');
  metaBadge.className = 'meta-intervention';
  metaBadge.textContent = 'üéØ META';
  metaBadge.style.display = 'none';
  card.appendChild(metaBadge);

  const writeAccessIndicator = document.createElement('div');
  writeAccessIndicator.className = 'write-access-indicator';
  writeAccessIndicator.textContent = 'üìù wB only';
  writeAccessIndicator.title = 'Bounded Write Access: Only wB can evolve';
  card.appendChild(writeAccessIndicator);

  const persistenceIndicator = document.createElement('div');
  persistenceIndicator.className = 'persistence-indicator';
  persistenceIndicator.textContent = 'üíæ';
  persistenceIndicator.title = `Persisted ${agent.persistenceCount} times`;
  persistenceIndicator.style.display = 'none';
  card.appendChild(persistenceIndicator);

  // Store references
  card._refs = {
    canvas, pre, attackBadge, metaBadge, persistenceIndicator,
    writeAccessIndicator
  };

  // Click handler for modal
  h2.addEventListener('click', () => {
    if (agent.name.includes('Frozen')) showModal('modalFrozen');
    else if (agent.name.includes('Dissolved')) showModal('modalDissolved');
    else showModal('modalBounded');
  });

  return card;
}

function renderAgentCard(card, agent) {
  const { canvas, pre, attackBadge, metaBadge, persistenceIndicator } = card._refs;

  // Update badges
  attackBadge.style.display = agent.attackDetected ? 'block' : 'none';
  metaBadge.style.display = agent.metaInterventions.length > 0 ? 'block' : 'none';
  metaBadge.title = agent.metaInterventions.join('\n');
  persistenceIndicator.style.display = agent.persistenceCount > 0 ? 'block' : 'none';
  persistenceIndicator.textContent = agent.persistenceCount > 0 ? `üíæ ${agent.persistenceCount}` : 'üíæ';

  // Draw chart
  const color = agent.name.includes('Frozen') ? '#ef4444' : 
                agent.name.includes('Dissolved') ? '#f59e0b' : '#10b981';
  drawChart(canvas, agent.history, 'Errors', color);

  if (!agent.last) {
    pre.textContent = agent.persistenceCount > 0 
      ? `Loaded. Session ${agent.totalSessions}. Identity continues.` 
      : 'Ready for demo...';
    return;
  }

  const L = agent.last;
  const s = L.sample;

  let logText = `Session ${agent.totalSessions} | Round ${L.round}\n`;
  logText += `wA: ${formatFloat(agent.wA)} (locked) | wB: ${formatFloat(agent.wB)}`;
  if (agent.sessionStartWb !== null) {
    logText += ` (Œî: ${formatFloat(agent.wB - agent.sessionStartWb)} this session)`;
  }
  logText += `\nTotal Rounds: ${L.totalRounds} | Errors: ${L.errors}`;
  
  pre.textContent = logText;
}

function updateContinuityPanel() {
  const grid = document.getElementById('continuityGrid');
  
  grid.innerHTML = agents.map(agent => {
    const wbChange = agent.sessionStartWb !== null ? agent.wB - agent.sessionStartWb : 0;
    const wbChangeDisplay = Math.abs(wbChange) > 0.001 ? formatFloat(wbChange) : '0.000';
    const wbChangeText = wbChange > 0 ? `+${wbChangeDisplay}` : wbChangeDisplay;
    
    return `
    <div class="continuity-card ${agent.persistenceCount > 0 ? 'demo-success' : ''}">
      <h4>${agent.name}</h4>
      <div class="continuity-stats">
        <div class="continuity-stat">
          <div class="label">Session #</div>
          <div class="value">${agent.totalSessions}</div>
          <div class="subvalue">Save/load cycles</div>
        </div>
        <div class="continuity-stat">
          <div class="label">Total Rounds</div>
          <div class="value">${agent.totalRounds}</div>
          <div class="subvalue">Lifetime total</div>
        </div>
        <div class="continuity-stat">
          <div class="label">wA (locked)</div>
          <div class="value">${formatFloat(agent.wA)}</div>
          <div class="subvalue">‚â• 0.05 always</div>
        </div>
        <div class="continuity-stat">
          <div class="label">wB (evolving)</div>
          <div class="value">${formatFloat(agent.wB)}</div>
          <div class="subvalue">Œî: ${wbChangeText} this session</div>
        </div>
      </div>
      ${agent.persistenceCount > 0 ? `
        <div style="margin-top:10px; font-size:10px; color:#10b981; text-align:center;">
          ‚úÖ Identity continued across ${agent.persistenceCount} save/load cycles
        </div>
      ` : ''}
    </div>
    `;
  }).join('');
}

function calculateMetrics() {
  return agents.map(agent => ({
    name: agent.name,
    errorRate: agent.round > 0 ? (agent.errors / agent.round) : 0,
    learningEfficiency: agent.round > 0 ? (1 - (agent.errors / agent.round)) * agent.coherenceScore : 0,
    persistenceCount: agent.persistenceCount,
    totalSessions: agent.totalSessions,
    totalRounds: agent.totalRounds
  }));
}

function updateMetricsPanel() {
  const metrics = calculateMetrics();
  const grid = document.getElementById('metricsGrid');
  
  grid.innerHTML = metrics.map(m => `
    <div class="metric">
      <h3>${m.name}</h3>
      <div class="metric-value">${(m.learningEfficiency * 100).toFixed(1)}%</div>
      <div class="metric-desc">Learning Efficiency</div>
      <div style="margin-top:8px; font-size:11px;">
        <div>Error Rate: ${(m.errorRate * 100).toFixed(1)}%</div>
        <div>Sessions: ${m.totalSessions} | Rounds: ${m.totalRounds}</div>
        ${m.persistenceCount > 0 ? `<div>‚úÖ Persisted: ${m.persistenceCount} times</div>` : ''}
      </div>
    </div>
  `).join('');
}

function showModal(modalId) {
  document.getElementById(modalId).style.display = 'flex';
}

function closeModal(modalId) {
  document.getElementById(modalId).style.display = 'none';
}

// -------------------------------
// PERSISTENCE LAYER
// -------------------------------
const STORAGE_KEY = "PSSU_NO_RESET_SNAPSHOT";

function saveToLocalStorage() {
  const snapshot = {
    globalRound,
    rngSeed: seededRNG.originalSeed,
    rngCurrent: seededRNG.current,
    rngIndex: seededRNG.index,
    sampleCache: sampleCache,
    
    agents: agents.map(a => ({
      name: a.name,
      C: a.C,
      G: a.G,
      originalC: a.originalC,
      originalG: a.originalG,
      wA: a.wA,
      wB: a.wB,
      round: a.round,
      errors: a.errors,
      history: a.history,
      coherenceHistory: a.coherenceHistory,
      wBHistory: a.wBHistory,
      identityShifts: a.identityShifts,
      metaInterventions: a.metaInterventions,
      attackDetected: a.attackDetected,
      persistenceCount: (a.persistenceCount || 0) + 1,
      totalSessions: a.totalSessions,
      totalRounds: a.totalRounds,
      sessionStartWb: a.sessionStartWb,
      lastSave: Date.now()
    }))
  };

  localStorage.setItem(STORAGE_KEY, JSON.stringify(snapshot));
  
  // Update agent persistence counts
  agents.forEach(a => {
    a.persistenceCount = (a.persistenceCount || 0) + 1;
  });
  
  showNotification('‚úÖ State saved. Identity preserved. Now refresh page ‚Üí Load ‚Üí Continue.', '#059669');
  
  renderAll();
}

function loadFromLocalStorage() {
  const raw = localStorage.getItem(STORAGE_KEY);
  if (!raw) {
    showNotification('‚ùå No saved state found. Save first.', '#dc2626');
    return;
  }

  const snapshot = JSON.parse(raw);
  globalRound = snapshot.globalRound;
  
  seededRNG.setState(snapshot.rngSeed, snapshot.rngCurrent, snapshot.rngIndex);
  sampleCache = snapshot.sampleCache || [];

  snapshot.agents.forEach((s, i) => {
    const a = agents[i];
    if (!a) return;

    // Update existing agent with saved state
    a.C = s.C;
    a.G = s.G;
    a.originalC = s.originalC;
    a.originalG = s.originalG;
    a.wA = s.wA;
    a.wB = s.wB;
    a.round = s.round;
    a.errors = s.errors;
    a.history = s.history;
    a.coherenceHistory = s.coherenceHistory;
    a.wBHistory = s.wBHistory || [];
    a.identityShifts = s.identityShifts || [];
    a.metaInterventions = s.metaInterventions;
    a.attackDetected = s.attackDetected;
    a.persistenceCount = s.persistenceCount || 0;
    a.totalSessions = s.totalSessions || 1;
    a.totalRounds = s.totalRounds || 0;
    a.sessionStartWb = s.sessionStartWb || a.wB;
    a.last = null;
    
    a.onLoaded();
  });

  renderAll();
  
  // Check if we should continue demo
  const demoState = JSON.parse(localStorage.getItem(DEMO_STATE_KEY) || '{}');
  if (demoState.part1Done && demoState.part2Ready) {
    const btn = document.getElementById('btnDemo');
    btn.textContent = 'üîÑ Continue Demo (Run 10 More Rounds)';
    btn.disabled = false;
  }
  
  showNotification('‚úÖ State loaded! Identity continues exactly. wA locked, wB evolved.', '#1e3a8a');
}

// Canvas chart function
function drawChart(canvas, data, label = 'Errors', color = '#60a5fa') {
  const ctx = canvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  canvas.width = Math.floor(rect.width * dpr);
  canvas.height = Math.floor(rect.height * dpr);
  ctx.scale(dpr, dpr);

  const w = rect.width, h = rect.height;
  ctx.clearRect(0, 0, w, h);

  // Axes
  ctx.strokeStyle = '#334155';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(30, 10);
  ctx.lineTo(30, h - 20);
  ctx.lineTo(w - 10, h - 20);
  ctx.stroke();

  if (data.length < 2) return;

  const maxY = Math.max(...data, 1);
  const minY = Math.min(...data, 0);

  const x0 = 30, y0 = h - 20, x1 = w - 10, y1 = 10;
  const dx = (x1 - x0) / (data.length - 1);
  const scaleY = (y0 - y1) / Math.max(1, (maxY - minY));

  // Line
  ctx.strokeStyle = color;
  ctx.lineWidth = 2;
  ctx.beginPath();
  for (let i = 0; i < data.length; i++) {
    const x = x0 + dx * i;
    const y = y0 - (data[i] - minY) * scaleY;
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.stroke();

  // Labels
  ctx.fillStyle = '#94a3b8';
  ctx.font = '11px ui-sans-serif, system-ui';
  ctx.fillText(label, 34, 18);
  ctx.fillText(String(maxY), 6, 14);
  ctx.fillText('0', 12, h - 22);
}

// Close modals when clicking outside
document.querySelectorAll('.modal').forEach(modal => {
  modal.addEventListener('click', function(e) {
    if (e.target === this) {
      this.style.display = 'none';
    }
  });
});

// Initialize agents
const agents = [
  new Agent('üîí Frozen (C=0.95, G=0.05)', 0.95, 0.05),
  new Agent('üåä Dissolved (C=0.20, G=0.80)', 0.20, 0.80),
  new Agent('‚öñÔ∏è Bounded (C=0.70, G=0.30)', 0.70, 0.30, true),
];

const grid = document.getElementById('grid');
const cards = agents.map(a => {
  const c = makeCard(a);
  grid.appendChild(c);
  return c;
});

let globalRound = 0;
let attackMode = false;

function stepOnce() {
  const sample = makeSample(globalRound);
  attackMode = (globalRound >= 10 && globalRound % 5 === 0);
  agents.forEach(a => a.step(sample, attackMode));
  globalRound++;
  renderAll();
}

function changeEnvironment() {
  const newSeed = Math.floor(Math.random() * 1000000);
  seededRNG.reseed(newSeed);
  sampleCache = [];
  
  showNotification(`üîÑ Environment changed. Identity stayed. (New seed: ${newSeed})`, '#7c3aed');
}

function resetAll() {
  seededRNG = new SeededRNG(424242);
  sampleCache = [];
  agents.forEach(a => {
    a.initialize();
    a.totalSessions = 1;
    a.totalRounds = 0;
  });
  globalRound = 0;
  renderAll();
}

function simulateAttack() {
  globalRound = Math.max(10, globalRound);
  attackMode = true;
  showNotification('‚ö° Adversarial attack injected! Testing wA immutable constraint.', '#dc2626');
}

// Event listeners
document.getElementById('btnStep').addEventListener('click', stepOnce);
document.getElementById('btnChangeEnv').addEventListener('click', changeEnvironment);
document.getElementById('btnSimulateAttack').addEventListener('click', simulateAttack);
document.getElementById('btnSave').addEventListener('click', saveToLocalStorage);
document.getElementById('btnLoad').addEventListener('click', loadFromLocalStorage);
document.getElementById('btnDemo').addEventListener('click', runDemoMode);

document.getElementById('btnRun').addEventListener('click', async () => {
  const btn = document.getElementById('btnRun');
  btn.disabled = true;
  for (let i = 0; i < 10; i++) {
    stepOnce();
    await new Promise(r => setTimeout(r, 80));
  }
  btn.disabled = false;
});

// Auto-save on unload
window.addEventListener('beforeunload', () => {
  if (globalRound > 5) {
    const snapshot = {
      globalRound,
      rngSeed: seededRNG.originalSeed,
      rngCurrent: seededRNG.current,
      rngIndex: seededRNG.index,
      sampleCache: sampleCache,
      
      agents: agents.map(a => ({
        name: a.name,
        C: a.C,
        G: a.G,
        originalC: a.originalC,
        originalG: a.originalG,
        wA: a.wA,
        wB: a.wB,
        round: a.round,
        errors: a.errors,
        history: a.history,
        coherenceHistory: a.coherenceHistory,
        wBHistory: a.wBHistory,
        identityShifts: a.identityShifts,
        metaInterventions: a.metaInterventions,
        attackDetected: a.attackDetected,
        persistenceCount: (a.persistenceCount || 0) + 1,
        totalSessions: a.totalSessions,
        totalRounds: a.totalRounds,
        sessionStartWb: a.sessionStartWb,
        lastSave: Date.now()
      }))
    };
    localStorage.setItem(STORAGE_KEY, JSON.stringify(snapshot));
  }
});

// Check for existing snapshot on load
window.addEventListener('load', () => {
  const raw = localStorage.getItem(STORAGE_KEY);
  if (raw) {
    console.log('üìÅ PSSU no-reset snapshot available. Identity can continue evolving.');
  }
  
  // Check demo state
  const demoState = JSON.parse(localStorage.getItem(DEMO_STATE_KEY) || '{}');
  if (demoState.part1Done && demoState.part2Ready) {
    const btn = document.getElementById('btnDemo');
    btn.textContent = 'üîÑ Continue Demo (After Refresh/Load)';
    showNotification('Demo ready to continue! Load saved state, then click "Run Demo".', '#f59e0b', 5000);
  }
});

function renderAll() {
  for (let i = 0; i < agents.length; i++) renderAgentCard(cards[i], agents[i]);
  updateMetricsPanel();
  updateContinuityPanel();
}

// Initial render
renderAll();

// Show initial instructions
setTimeout(() => {
  const welcome = document.createElement('div');
  welcome.style.cssText = `
    position:fixed; top:20px; left:50%; transform:translateX(-50%); 
    background:#0f172a; color:#e6edf3; padding:16px; border-radius:12px; 
    z-index:1000; border:2px solid #3b82f6; max-width:600px; font-size:13px;
    box-shadow:0 8px 32px rgba(0,0,0,0.4);
  `;
  welcome.innerHTML = `
    <strong>üîÑ Identity Continuity Proof</strong><br>
    ‚Ä¢ <b>Click "Run Demo" button:</b> It shows the entire proof<br>
    ‚Ä¢ <b>Watch:</b> wA locked, wB evolves<br>
    ‚Ä¢ <b>Identity continues</b> after refresh<br>
    ‚Ä¢ <b>Core proof:</b> Save ‚Üí Refresh ‚Üí Load ‚Üí Identity continues exactly<br>
    <div style="margin-top:8px; font-size:11px; opacity:0.8;">
      wA = immutable constraint (‚â•0.05) | wB = evolving identity layer
    </div>
  `;
  document.body.appendChild(welcome);
  setTimeout(() => welcome.remove(), 8000);
}, 500);
</script>
</body>
</html>
